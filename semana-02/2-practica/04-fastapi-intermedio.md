# Pr√°ctica 4: FastAPI Intermedio - Semana 2

## üéØ Objetivo

Expandir la API de Semana 1 con caracter√≠sticas intermedias de FastAPI, construyendo sobre los modelos Pydantic del bloque anterior.

## ‚è±Ô∏è Tiempo Estimado: 90 minutos

## üìã Pre-requisitos

- ‚úÖ API de Semana 1 funcionando
- ‚úÖ Modelos Pydantic implementados (bloque anterior)
- ‚úÖ Conocimiento b√°sico de HTTP methods

## üîÑ Continuando desde la API Anterior

Vamos a expandir la API que ya tienes con m√©todos HTTP adicionales y caracter√≠sticas avanzadas:

## üöÄ Paso 1: M√©todos HTTP Completos (25 min)

Agregar operaciones CRUD completas a tu `main.py`:

```python
# Importaciones adicionales
from fastapi import FastAPI, HTTPException, status, Query, Path, Body
from typing import Optional, List, Dict, Any

# Modelo para actualizaci√≥n parcial
class PersonaUpdate(BaseModel):
    nombre: Optional[str] = Field(None, min_length=2, max_length=50)
    edad: Optional[int] = Field(None, ge=18, le=120)
    email: Optional[EmailStr] = None
    categoria: Optional[CategoriaPersona] = None
    activo: Optional[bool] = None

# PUT - Actualizaci√≥n completa
@app.put("/personas/{persona_id}", response_model=PersonaResponse)
def actualizar_persona_completa(
    persona_id: int = Path(..., ge=1, description="ID de la persona"),
    persona_nueva: PersonaCreate = Body(..., description="Datos completos de la persona")
):
    """Actualizar todos los datos de una persona"""
    # Buscar persona existente
    for i, persona in enumerate(personas):
        if persona.id == persona_id:
            # Crear nueva instancia con ID y timestamp preservados
            persona_actualizada = PersonaResponse(
                id=persona.id,
                timestamp=persona.timestamp,
                **persona_nueva.dict()
            )
            personas[i] = persona_actualizada
            return persona_actualizada

    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail=f"Persona con ID {persona_id} no encontrada"
    )

# PATCH - Actualizaci√≥n parcial
@app.patch("/personas/{persona_id}", response_model=PersonaResponse)
def actualizar_persona_parcial(
    persona_id: int = Path(..., ge=1),
    persona_update: PersonaUpdate = Body(...)
):
    """Actualizar solo algunos campos de una persona"""
    for i, persona in enumerate(personas):
        if persona.id == persona_id:
            # Crear diccionario con datos actuales
            datos_actuales = persona.dict()

            # Actualizar solo campos proporcionados
            datos_nuevos = persona_update.dict(exclude_unset=True)
            datos_actuales.update(datos_nuevos)

            # Crear nueva instancia
            persona_actualizada = PersonaResponse(**datos_actuales)
            personas[i] = persona_actualizada
            return persona_actualizada

    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail=f"Persona con ID {persona_id} no encontrada"
    )

# DELETE - Eliminar
@app.delete("/personas/{persona_id}", status_code=status.HTTP_204_NO_CONTENT)
def eliminar_persona(persona_id: int = Path(..., ge=1)):
    """Eliminar una persona (soft delete)"""
    for i, persona in enumerate(personas):
        if persona.id == persona_id:
            # Soft delete - marcar como inactivo
            persona.activo = False
            return  # 204 No Content no retorna body

    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail=f"Persona con ID {persona_id} no encontrada"
    )

# DELETE - Eliminar permanentemente
@app.delete("/personas/{persona_id}/permanente")
def eliminar_persona_permanente(persona_id: int = Path(..., ge=1)):
    """Eliminar persona permanentemente"""
    for i, persona in enumerate(personas):
        if persona.id == persona_id:
            persona_eliminada = personas.pop(i)
            return {
                "mensaje": "Persona eliminada permanentemente",
                "persona": persona_eliminada
            }

    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail=f"Persona con ID {persona_id} no encontrada"
    )
```

## üîç Paso 2: Par√°metros de Consulta Avanzados (20 min)

```python
# Endpoint con m√∫ltiples par√°metros de consulta
@app.get("/personas/buscar", response_model=List[PersonaResponse])
def buscar_personas(
    # Par√°metros de filtro
    nombre: Optional[str] = Query(None, min_length=2, description="Buscar por nombre"),
    categoria: Optional[CategoriaPersona] = Query(None, description="Filtrar por categor√≠a"),
    edad_min: Optional[int] = Query(None, ge=18, description="Edad m√≠nima"),
    edad_max: Optional[int] = Query(None, le=120, description="Edad m√°xima"),
    activo: bool = Query(True, description="Filtrar por estado activo"),

    # Par√°metros de paginaci√≥n
    page: int = Query(1, ge=1, description="N√∫mero de p√°gina"),
    size: int = Query(10, ge=1, le=100, description="Elementos por p√°gina"),

    # Par√°metros de ordenamiento
    order_by: str = Query("id", regex="^(id|nombre|edad|categoria)$", description="Campo para ordenar"),
    order_direction: str = Query("asc", regex="^(asc|desc)$", description="Direcci√≥n del ordenamiento")
):
    """B√∫squeda avanzada de personas con filtros, paginaci√≥n y ordenamiento"""

    # Aplicar filtros
    resultado = [p for p in personas if p.activo == activo]

    if nombre:
        resultado = [p for p in resultado if nombre.lower() in p.nombre.lower()]

    if categoria:
        resultado = [p for p in resultado if p.categoria == categoria]

    if edad_min is not None:
        resultado = [p for p in resultado if p.edad >= edad_min]

    if edad_max is not None:
        resultado = [p for p in resultado if p.edad <= edad_max]

    # Ordenamiento
    reverse = order_direction == "desc"
    resultado.sort(key=lambda x: getattr(x, order_by), reverse=reverse)

    # Paginaci√≥n
    total = len(resultado)
    inicio = (page - 1) * size
    fin = inicio + size
    resultado_paginado = resultado[inicio:fin]

    # Agregar metadata de paginaci√≥n en headers (buena pr√°ctica)
    return resultado_paginado

# Endpoint de estad√≠sticas
@app.get("/personas/estadisticas")
def obtener_estadisticas_personas():
    """Obtener estad√≠sticas de personas"""
    if not personas:
        return {"mensaje": "No hay personas registradas"}

    # Calcular estad√≠sticas
    activas = [p for p in personas if p.activo]
    por_categoria = {}
    edades = [p.edad for p in activas]

    for categoria in CategoriaPersona:
        por_categoria[categoria.value] = len([p for p in activas if p.categoria == categoria])

    return {
        "total_personas": len(personas),
        "personas_activas": len(activas),
        "personas_inactivas": len(personas) - len(activas),
        "por_categoria": por_categoria,
        "edad_promedio": round(sum(edades) / len(edades), 1) if edades else 0,
        "edad_minima": min(edades) if edades else 0,
        "edad_maxima": max(edades) if edades else 0
    }
```

## üìä Paso 3: Response Models y Status Codes (20 min)

```python
# Modelos de respuesta especializados
class PersonaResumen(BaseModel):
    """Modelo resumido para listados"""
    id: int
    nombre: str
    categoria: CategoriaPersona
    activo: bool

class OperacionExitosa(BaseModel):
    """Modelo para operaciones exitosas"""
    success: bool = True
    mensaje: str
    data: Optional[Dict[str, Any]] = None

class ErrorDetalle(BaseModel):
    """Modelo para errores detallados"""
    error: str
    detalle: str
    codigo: int
    timestamp: datetime = Field(default_factory=datetime.now)

# Endpoint con m√∫ltiples response models
@app.get("/personas/resumen",
         response_model=List[PersonaResumen],
         responses={
             200: {"description": "Lista de personas resumida"},
             404: {"model": ErrorDetalle, "description": "No se encontraron personas"}
         })
def obtener_resumen_personas():
    """Obtener resumen de todas las personas activas"""
    activas = [p for p in personas if p.activo]

    if not activas:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No se encontraron personas activas"
        )

    return [PersonaResumen(**p.dict()) for p in activas]

# Endpoint con respuesta customizada
@app.post("/personas/batch",
          response_model=OperacionExitosa,
          status_code=status.HTTP_201_CREATED)
def crear_personas_lote(personas_nuevas: List[PersonaCreate]):
    """Crear m√∫ltiples personas en una operaci√≥n"""
    if len(personas_nuevas) > 10:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No se pueden crear m√°s de 10 personas por lote"
        )

    personas_creadas = []
    for persona_data in personas_nuevas:
        # Verificar email √∫nico
        if any(p.email == persona_data.email for p in personas):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Email {persona_data.email} ya existe"
            )

        nueva_persona = PersonaResponse(
            id=len(personas) + len(personas_creadas) + 1,
            timestamp=datetime.now(),
            **persona_data.dict()
        )
        personas_creadas.append(nueva_persona)

    # Agregar todas las personas
    personas.extend(personas_creadas)

    return OperacionExitosa(
        mensaje=f"Se crearon {len(personas_creadas)} personas exitosamente",
        data={"personas_creadas": len(personas_creadas)}
    )
```

## üîß Paso 4: Middleware y Headers Custom (15 min)

```python
from fastapi.middleware.cors import CORSMiddleware
from fastapi import Request
import time

# Configurar CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # En producci√≥n, ser m√°s espec√≠fico
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Middleware custom para timing
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    """Agregar header con tiempo de procesamiento"""
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(round(process_time, 4))
    return response

# Endpoint con headers custom
@app.get("/health/detailed")
def health_check_detailed():
    """Health check con informaci√≥n detallada"""
    return {
        "status": "healthy",
        "version": "2.0.0",
        "timestamp": datetime.now().isoformat(),
        "total_personas": len(personas),
        "personas_activas": len([p for p in personas if p.activo]),
        "memoria_usada_mb": "N/A"  # En producci√≥n, usar psutil
    }
```

## üß™ Paso 5: Testing de Endpoints (10 min)

Crear script de testing r√°pido:

```python
# test_endpoints.py
import requests
import json

BASE_URL = "http://localhost:8000"

def test_crud_completo():
    """Test del flujo CRUD completo"""
    print("üß™ Testing CRUD completo...")

    # 1. Crear persona
    nueva_persona = {
        "nombre": "Mar√≠a Test",
        "edad": 30,
        "email": "maria.test@ejemplo.com",
        "categoria": "estudiante"
    }

    response = requests.post(f"{BASE_URL}/personas", json=nueva_persona)
    assert response.status_code == 201
    persona_creada = response.json()
    persona_id = persona_creada["id"]
    print(f"‚úÖ Persona creada con ID {persona_id}")

    # 2. Leer persona
    response = requests.get(f"{BASE_URL}/personas/{persona_id}")
    assert response.status_code == 200
    print("‚úÖ Persona le√≠da correctamente")

    # 3. Actualizar persona (PATCH)
    update_data = {"edad": 31}
    response = requests.patch(f"{BASE_URL}/personas/{persona_id}", json=update_data)
    assert response.status_code == 200
    persona_actualizada = response.json()
    assert persona_actualizada["edad"] == 31
    print("‚úÖ Persona actualizada con PATCH")

    # 4. Buscar personas
    response = requests.get(f"{BASE_URL}/personas/buscar?nombre=Mar√≠a")
    assert response.status_code == 200
    resultados = response.json()
    assert len(resultados) >= 1
    print("‚úÖ B√∫squeda funcionando")

    # 5. Eliminar persona (soft delete)
    response = requests.delete(f"{BASE_URL}/personas/{persona_id}")
    assert response.status_code == 204
    print("‚úÖ Soft delete funcionando")

    print("üéâ Todos los tests pasaron!")

if __name__ == "__main__":
    test_crud_completo()
```

## üéØ Objetivos Logrados

Al finalizar esta pr√°ctica, habr√°s implementado:

- ‚úÖ **CRUD completo** (Create, Read, Update, Delete)
- ‚úÖ **M√∫ltiples m√©todos HTTP** (GET, POST, PUT, PATCH, DELETE)
- ‚úÖ **Par√°metros de consulta avanzados** con validaci√≥n
- ‚úÖ **Paginaci√≥n y ordenamiento** b√°sicos
- ‚úÖ **Response models especializados** seg√∫n contexto
- ‚úÖ **Status codes apropiados** para cada operaci√≥n
- ‚úÖ **Middleware custom** para timing y CORS
- ‚úÖ **Testing b√°sico** de endpoints

## üìä Comparaci√≥n: Semana 1 vs Semana 2

| Aspecto          | Semana 1             | Semana 2                           |
| ---------------- | -------------------- | ---------------------------------- |
| **Endpoints**    | 4-5 b√°sicos          | 12+ con CRUD completo              |
| **M√©todos HTTP** | GET, POST            | GET, POST, PUT, PATCH, DELETE      |
| **Validaci√≥n**   | B√°sica               | Avanzada con Pydantic              |
| **Par√°metros**   | Simples              | Query params con validaci√≥n        |
| **Respuestas**   | JSON simple          | Response models + status codes     |
| **Features**     | Funcionalidad b√°sica | B√∫squeda, paginaci√≥n, estad√≠sticas |

## üîÑ Pr√≥ximos Pasos

1. **Prueba todos los endpoints** con diferentes par√°metros
2. **Experimenta con la documentaci√≥n** en `/docs`
3. **Semana 3**: Conectar a base de datos real
4. **Semana 4**: A√±adir autenticaci√≥n y autorizaci√≥n

## üìù Entregable de Este Bloque

- **API con CRUD completo** funcionando
- **Al menos 12 endpoints** diferentes
- **B√∫squeda y filtros** implementados
- **Testing b√°sico** pasando
- **Documentaci√≥n actualizada** en `/docs`

---

**üí° Tip**: Tu API ahora tiene caracter√≠sticas de nivel profesional. ¬°La documentaci√≥n autom√°tica en `/docs` se ve incre√≠ble con todos estos endpoints!
